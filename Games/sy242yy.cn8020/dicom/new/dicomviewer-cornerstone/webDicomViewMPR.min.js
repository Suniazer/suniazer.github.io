(Object("undefined" != typeof self ? self : this).webpackChunkdicom_webview = Object("undefined" != typeof self ? self : this).webpackChunkdicom_webview || []).push([
    [385], {
        1234: () => {},
        2590: (e, t, o) => {
            "use strict";
            o.r(t), o.d(t, {
                default: () => Qt
            });
            var n = o(3678),
                i = o(7073),
                r = o(4621),
                s = o(245),
                a = o(6567),
                l = o(8023),
                d = o(666),
                c = o(4486),
                u = o(2710),
                v = o(8346),
                g = o(7058),
                A = o(4594);
            const m = "cornerstoneStreamingImageVolume",
                p = "myRenderingEngine",
                h = "CT_VOLUME_ID",
                f = "PT_VOLUME_ID",
                I = `${m}:${h}`,
                T = `${m}:${f}`,
                y = "VOLUME_3D_TOOLGROUP_ID",
                R = ["CT_AXIAL", "CT_SAGITTAL", "CT_CORONAL"],
                w = ["PT_AXIAL", "PT_SAGITTAL", "PT_CORONAL"],
                O = ["FUSION_AXIAL", "FUSION_SAGITTAL", "FUSION_CORONAL"],
                L = "VOLUME_3D",
                P = {
                    toolGroupId: y,
                    viewportIds: [L],
                    VOLUME_3D: L
                },
                C = {
                    CT: {
                        volumeName: h,
                        volumeId: I,
                        toolGroupId: "CT_TOOLGROUP_ID",
                        viewportIds: R,
                        AXIAL: R[0],
                        SAGITTAL: R[1],
                        CORONAL: R[2]
                    },
                    PT: {
                        volumeName: f,
                        volumeId: T,
                        toolGroupId: "PT_TOOLGROUP_ID",
                        viewportIds: w,
                        AXIAL: w[0],
                        SAGITTAL: w[1],
                        CORONAL: w[2]
                    },
                    fusion: {
                        toolGroupId: "FUSION_TOOLGROUP_ID",
                        viewportIds: O,
                        AXIAL: O[0],
                        SAGITTAL: O[1],
                        CORONAL: O[2]
                    }
                };
            let b, M, S, E;

            function N(e) {
                M = e
            }

            function _(e) {
                S = e
            }

            function D(e) {
                E = e
            }
            let V = [];

            function G(e) {
                return e || !V.length ? (V = [{
                    id: C.CT.AXIAL,
                    style: "",
                    class: "leftElement",
                    visibility: !0
                }, {
                    id: C.CT.SAGITTAL,
                    style: "",
                    class: "rightElement",
                    visibility: !0
                }, {
                    id: C.CT.CORONAL,
                    style: "",
                    class: "rightElement",
                    visibility: !0
                }, {
                    id: L,
                    style: "",
                    class: "rightElement",
                    visibility: null === (t = A.A.webDicomView.layoutView.toolsDataMPR.find((e => "MPRViewportPresets" === e.toolTag))) || void 0 === t ? void 0 : t.visibility
                }], V) : V;
                var t
            }
            let k = 0;
            let F = null;

            function U(e) {
                F = e
            }
            const x = function(e) {
                var t;
                const {
                    removeMetadataProvider: o = !1,
                    unregisterImageLoaders: A = !0,
                    cleanupDOMElements: m = !0
                } = e || {};
                if (d.us(), c.j(), i.Ay.purgeCache(), (0, n.OU)(), (0, u.zr)(), null === (t = (0, r.qO)()) || void 0 === t || t.forEach((e => {
                        e.destroy()
                    })), o && s && s.removeAllProviders(), A && a && a.unregisterAllImageLoaders(), v && g.A(), l.A && l.A.reset(), i.Ay.purgeCache(), m) {
                    const e = b || document;
                    [...e.querySelectorAll(".viewport-element"), ...e.querySelectorAll("svg"), ...e.querySelectorAll("canvas"), ...e.querySelectorAll("div"), ...e.querySelectorAll(".cornerstone-canvas")].forEach((e => {
                        e.parentNode && e.parentNode.removeChild(e)
                    }))
                }
            };
            var q = o(8369),
                B = o(5743);
            var X = o(4602),
                H = o(7185),
                $ = o(8849),
                W = o(7638),
                z = o(6811),
                j = o(9313),
                Y = o(3211),
                Z = o(5872),
                K = o(2065),
                J = o(1448),
                Q = o(2693),
                ee = o(6671),
                te = o(9181),
                oe = o(1948),
                ne = o.n(oe);
            const ie = (e = ne()) => {
                e.external.cornerstone = te
            };
            var re = o(7471),
                se = o(6581),
                ae = o(4508),
                le = o(7877),
                de = o(2117),
                ce = function(e, t, o, n) {
                    return new(o || (o = Promise))((function(i, r) {
                        function s(e) {
                            try {
                                l(n.next(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function a(e) {
                            try {
                                l(n.throw(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value, t instanceof o ? t : new o((function(e) {
                                e(t)
                            }))).then(s, a)
                        }
                        l((n = n.apply(e, t || [])).next())
                    }))
                };
            let ue;
            const ve = {
                value: void 0,
                get: function() {
                    return ce(this, void 0, void 0, (function*() {
                        return this.value || (yield this.init())
                    }))
                },
                init: function() {
                    return ce(this, void 0, void 0, (function*() {
                        var e;
                        try {
                            if (null === (e = this.value) || void 0 === e ? void 0 : e.gpu) return this.value;
                            ue = ue || de.Ay.translate("toast.MPR");
                            const {
                                GPUBenchmarksURL: t,
                                publicPath: o
                            } = A.A.instanceOptions, n = t || `${(0,ae.A)()}GPUbenchmarks`;
                            o || console.warn(ue.GPUBenchmarksURL.null, n);
                            const i = yield fetch(`${n}/m-samsung.json`);
                            if (200 !== i.status) throw new Error("GPUBenchmarks file request failed.");
                            if (!Array.isArray(yield i.json())) throw new Error("GPUBenchmarks data type is wrong.");
                            const r = (0, le.Z)({
                                benchmarksURL: n
                            });
                            return r.then((e => {
                                this.value = e, console.info(e)
                            })), r
                        } catch (e) {
                            return console.error(e), console.error(ue.GPUBenchmarksURL.error), this.value = {
                                tier: 2,
                                type: "FALLBACK",
                                isMobile: A.A.isMobile
                            }
                        }
                    }))
                }
            };
            var ge = function(e, t, o, n) {
                return new(o || (o = Promise))((function(i, r) {
                    function s(e) {
                        try {
                            l(n.next(e))
                        } catch (e) {
                            r(e)
                        }
                    }

                    function a(e) {
                        try {
                            l(n.throw(e))
                        } catch (e) {
                            r(e)
                        }
                    }

                    function l(e) {
                        var t;
                        e.done ? i(e.value) : (t = e.value, t instanceof o ? t : new o((function(e) {
                            e(t)
                        }))).then(s, a)
                    }
                    l((n = n.apply(e, t || [])).next())
                }))
            };
            const Ae = i.Ay.getImage;
            let me;

            function pe() {
                return ge(this, void 0, void 0, (function*() {
                    var e, t, o;
                    const {
                        isMobile: n
                    } = A.A;
                    me = me || de.Ay.translate("toast.MPR"), q.registerUnknownVolumeLoader(B.F), q.registerVolumeLoader("cornerstoneStreamingImageVolume", B.F), !(0, H.Dh)() && (yield(0, H.Ts)({
                        gpuTier: {
                            tier: (null === (e = yield ve.get()) || void 0 === e ? void 0 : e.tier) || 2
                        },
                        rendering: {
                            preferSizeOverAccuracy: !0,
                            useCPURendering: !1,
                            strictZSpacingForVolumeViewport: !1
                        },
                        isMobile: n
                    }));
                    const {
                        hardwareConcurrency: r = 2
                    } = navigator;
                    switch (X.A.maxNumRequests = {
                        interaction: r / 2,
                        thumbnail: r / 2,
                        prefetch: r,
                        compute: 2 * r
                    }, A.A.imageType) {
                        case -1:
                        case 0:
                            (0, se.Up)(a.registerImageLoader), (0, se.wj)(a.registerImageLoader);
                            break;
                        case 1:
                            ie()
                    }(0, u.Ts)(), (0, re.jt)(s);
                    const {
                        isFusionMode: l,
                        seriesData: d
                    } = S, {
                        isWeb: c,
                        rows: v,
                        columns: g
                    } = s.get("_grayImageModule", l ? null === (t = d.fusionData) || void 0 === t ? void 0 : t.PT.loadIds[0] : null === (o = d.series) || void 0 === o ? void 0 : o.loadIds[0]);
                    i.Ay.setMaxCacheSize(c ? v * g * 4 * 12 : 17179869184), (0, $.Gx)(W.A), (0, $.Gx)(z.A), (0, $.Gx)(j.A), (0, $.Gx)(Y.A), (0, $.Gx)(Z.A), (0, $.Gx)(K.A), (0, $.Gx)(J.A), (0, $.Gx)(Q.A), (0, $.Gx)(ee.A)
                }))
            }
            i.Ay.getImage = (e, t) => {
                var o;
                const n = Ae.call(i.Ay, e, t);
                if (n) return n;
                if (null === (o = null == F ? void 0 : F.loadStatus) || void 0 === o ? void 0 : o.loaded) throw a.loadAndCacheImage(e), "go to reloaded: " + e
            };

            function he({
                volumeActor: e
            }) {
                e.getProperty().getRGBTransferFunction(0).setMappingRange(-160, 240)
            }
            var fe = o(3534),
                Ie = o(3821),
                Te = o(1019);
            const ye = {
                0: {
                    mappingRange: [0, 5],
                    addPointPiecewise: [
                        [0, 0],
                        [.1, .9],
                        [5, 1]
                    ]
                },
                1: {
                    mappingRange: [0, 13106],
                    addPointPiecewise: [
                        [0, 0],
                        [.1, .9],
                        [6553, 1]
                    ]
                },
                2: {
                    mappingRange: [0, 13106],
                    addPointPiecewise: [
                        [0, 0],
                        [1310, .9],
                        [13106, 1]
                    ]
                },
                3: {
                    mappingRange: [0, 32766],
                    addPointPiecewise: [
                        [0, 0],
                        [3276, .9],
                        [32766, 1]
                    ]
                }
            };
            let Re = ye[1];
            const we = {
                paramsPresetMap: ye,
                addPreset: (e, t) => {
                    ye[e] = t
                },
                getPreset: () => Re,
                applyPreset: e => {
                    const t = ye[e];
                    if (t) {
                        const e = document.querySelector(".toolsMPR .MPRReset");
                        return Re = t, void(null == e || e.click())
                    }
                    throw new Error(`preset name：${e} is not defined, Existing preset code：${Object.keys(ye)}`)
                }
            };

            function Oe(e) {
                const {
                    mappingRange: t = [0, 1],
                    addPointPiecewise: o = []
                } = Re, {
                    volumeActor: n,
                    preset: i
                } = e;
                n.getMapper().setSampleDistance(1);
                const r = Ie.Ay.newInstance();
                let s = i || fe.A.getPresetByName("hsv");
                r.applyColorMap(s), r.setMappingRange(...t), n.getProperty().setRGBTransferFunction(0, r);
                const a = Te.Ay.newInstance();
                for (const [e, t] of o) a.addPoint(e, t);
                n.getProperty().setScalarOpacity(0, a)
            }
            o.g.petColorMapMapping = we;
            var Le = o(4805);

            function Pe({
                volumeActor: e
            }) {
                const {
                    mappingRange: t = [0, 1]
                } = Re, o = e.getProperty().getRGBTransferFunction(0);
                o.setRange(...t), Le.A(o)
            }
            var Ce = o(9584),
                be = o(1706),
                Me = o(3451),
                Se = o(6269),
                Ee = o(4006),
                Ne = o(9618),
                _e = o(7883),
                De = o(4012),
                Ve = o(1540),
                Ge = o(4683),
                ke = o(9188),
                Fe = function(e, t, o, n) {
                    return new(o || (o = Promise))((function(i, r) {
                        function s(e) {
                            try {
                                l(n.next(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function a(e) {
                            try {
                                l(n.throw(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value, t instanceof o ? t : new o((function(e) {
                                e(t)
                            }))).then(s, a)
                        }
                        l((n = n.apply(e, t || [])).next())
                    }))
                };
            const {
                ViewportType: Ue,
                OrientationAxis: xe
            } = be;

            function qe(e, t) {
                return Fe(this, void 0, void 0, (function*() {
                    const o = yield q.createAndCacheVolume(e, {
                        imageIds: t
                    });
                    if (U(o), null == o ? void 0 : o.getImageLoadRequests) {
                        (function(e) {
                            const t = Math.floor(e.length / 2);
                            return e.map(((e, o) => ({
                                value: e,
                                distance: Math.abs(o - t)
                            }))).sort(((e, t) => e.distance - t.distance)).map((e => e.value))
                        })(o.getImageLoadRequests()).forEach((e => {
                            const {
                                callLoadImage: t,
                                requestType: o,
                                additionalDetails: n,
                                priority: i,
                                imageId: r,
                                imageIdIndex: s,
                                options: a
                            } = e;
                            X.A.addRequest(t.bind(null, r, s, a), o, n, i)
                        }))
                    } else o.load()
                }))
            }
            var Be = o(4134),
                Xe = o(1026);
            const {
                iP: He,
                qv: $e,
                r$: We
            } = Ge, {
                isMobile: ze
            } = A.A, je = {
                AXIAL: "rgb(200, 0, 0)",
                CORONAL: "rgb(0, 200, 0)",
                SAGITTAL: "rgb(200, 200, 0)"
            };

            function Ye() {
                Be.A(y)
            }

            function Ze(e) {
                const t = ke.A(e) || Xe.A(e);
                if (!t) throw `toolGroup: ${e} is undefined for createToolGroup`;
                return t
            }

            function Ke(e, t, o = []) {
                const n = Ze(e);
                return t.forEach((e => {
                    n.addViewport(e, p)
                })), o.forEach((({
                    toolClass: e,
                    toolName: t,
                    toolConfiguration: o,
                    toolBindingsOptions: i,
                    disOtherActive: r
                }) => {
                    e && (0, $.Gx)(e), n.addTool(t, o), Je(n, t, i, r)
                })), n
            }

            function Je(e, t, o, n = !1) {
                const i = e instanceof Object ? e : Ze(e);
                n && function(e) {
                    const t = e.currentActivePrimaryToolName || e.getActivePrimaryMouseButtonTool();
                    t && e.setToolMode(t, A.A.isMobile ? We.Disabled : We.Passive)
                }(i), i.setToolActive(t, o)
            }
            var Qe = o(8018);
            const {
                Tv: et,
                LD: tt
            } = Qe;
            let ot, nt, it, rt, st, at;
            const lt = function() {
                const {
                    isFusionMode: e
                } = S;
                if (!e || E) {
                    if (g.A(), ot = null, nt = null, it = null, rt = null, st = null, at = null, ot = tt("CT_VOI_SYNCHRONIZER_ID", {
                            syncInvertState: !1,
                            syncColormap: !1
                        }), !e) return [...C.CT.viewportIds, P.VOLUME_3D].forEach((e => {
                        M.getViewport(e) && ot.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    }));
                    if (nt = tt("PT_VOI_SYNCHRONIZER_ID", {
                            syncInvertState: !1,
                            syncColormap: !1
                        }), it = tt("FUTION_VOI_SYNCHRONIZER_ID", {
                            syncInvertState: !1,
                            syncColormap: !1
                        }), rt = et("AXIAL_CAMERA_SYNCHRONIZER_ID"), "ACS9" !== E) return C.CT.viewportIds.forEach((e => {
                        rt.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), [C.CT.SAGITTAL, P.VOLUME_3D].forEach((e => {
                        M.getViewport(e) && ot.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), nt.add({
                        renderingEngineId: p,
                        viewportId: C.CT.CORONAL
                    }), it.add({
                        renderingEngineId: p,
                        viewportId: C.CT.AXIAL
                    }), ot.addTarget({
                        renderingEngineId: p,
                        viewportId: C.CT.AXIAL
                    }), void nt.addTarget({
                        renderingEngineId: p,
                        viewportId: C.CT.AXIAL
                    });
                    st = et("SAGITTAL_CAMERA_SYNCHRONIZER_ID"), at = et("CORONAL_CAMERA_SYNCHRONIZER_ID"), [C.CT.AXIAL, C.PT.AXIAL, C.fusion.AXIAL].forEach((e => {
                        rt.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), [C.CT.SAGITTAL, C.PT.SAGITTAL, C.fusion.SAGITTAL].forEach((e => {
                        st.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), [C.CT.CORONAL, C.PT.CORONAL, C.fusion.CORONAL].forEach((e => {
                        at.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), [...C.CT.viewportIds, P.VOLUME_3D].forEach((e => {
                        M.getViewport(e) && ot.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), C.PT.viewportIds.forEach((e => {
                        nt.add({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    })), C.fusion.viewportIds.forEach((e => {
                        it.add({
                            renderingEngineId: p,
                            viewportId: e
                        }), ot.addTarget({
                            renderingEngineId: p,
                            viewportId: e
                        }), nt.addTarget({
                            renderingEngineId: p,
                            viewportId: e
                        })
                    }))
                }
            };
            var dt = o(9941);
            const ct = {
                lower: -1e3,
                upper: 1e3
            };

            function ut(e, t) {
                var o;
                const {
                    viewport: n
                } = (0, dt.Ay)(e) || {}, r = null == n ? void 0 : n.getImageActor(t);
                if (!r) return ct;
                const s = r.getMapper().getInputData().getPointData().getScalars();
                let a;
                if (s) a = s.getRange();
                else {
                    if (!t) throw new Error("volumeId is required when scalarData is not available");
                    const e = i.Ay.getVolume(t);
                    if (!e) throw "volume must be provided for getImageRange";
                    const [n, r] = (null === (o = e.voxelManager) || void 0 === o ? void 0 : o.getRange()) || [];
                    a = [n, r]
                }
                return 0 === a[0] && 0 === a[1] ? ct : {
                    lower: a[0],
                    upper: a[1]
                }
            }

            function vt(e, t) {
                var o;
                const {
                    viewport: n
                } = (0, dt.Ay)(e) || {}, i = null == n ? void 0 : n.getImageActor(t);
                if (!i) return ct;
                const r = null === (o = i.getProperty().getRGBTransferFunction(0)) || void 0 === o ? void 0 : o.getRange();
                if (!r) throw "voiRange must be provided for getVOIRange";
                return 0 === r[0] && 0 === r[1] ? ct : {
                    lower: r[0],
                    upper: r[1]
                }
            }

            function gt(e, t, o) {
                return [e[0] * (1 - o) + t[0] * o, e[1] * (1 - o) + t[1] * o, e[2] * (1 - o) + t[2] * o]
            }
            const At = e => !!e && e.width > 0 && e.height > 0,
                mt = e => e && e.upper > e.lower,
                pt = (e, t) => !!e && !!t && e.lower === t.lower && e.upper === t.upper;
            class ht {
                constructor(e) {
                    ht.validateProps(e);
                    const {
                        colormap: t,
                        size: o = {
                            width: 20,
                            height: 100
                        },
                        imageRange: n = {
                            lower: 0,
                            upper: 1
                        },
                        voiRange: i = {
                            lower: 0,
                            upper: 1
                        },
                        container: r,
                        showFullPixelValueRange: s = !1
                    } = e;
                    this._colormap = t, this._imageRange = n, this._voiRange = i, this._showFullImageRange = s, this._canvas = this._createRootElement(o), r && this.appendTo(r)
                }
                get colormap() {
                    return this._colormap
                }
                set colormap(e) {
                    this._colormap = e, this.render()
                }
                get size() {
                    const {
                        width: e,
                        height: t
                    } = this._canvas;
                    return {
                        width: e,
                        height: t
                    }
                }
                set size(e) {
                    const {
                        _canvas: t
                    } = this;
                    var o, n;
                    !At(e) || (n = e, (o = t) && n && o.width === n.width && o.height === n.height) || (this._setCanvasSize(t, e), this.render())
                }
                get imageRange() {
                    return Object.assign({}, this._imageRange)
                }
                set imageRange(e) {
                    mt(e) && !pt(e, this._imageRange) && (this._imageRange = e, this.render())
                }
                get voiRange() {
                    return Object.assign({}, this._voiRange)
                }
                set voiRange(e) {
                    mt(e) && !pt(e, this._voiRange) && (this._voiRange = e, this.render())
                }
                get showFullImageRange() {
                    return this._showFullImageRange
                }
                set showFullImageRange(e) {
                    e !== this._showFullImageRange && (this._showFullImageRange = e, this.render())
                }
                appendTo(e) {
                    e.appendChild(this._canvas), this.render()
                }
                dispose() {
                    const {
                        _canvas: e
                    } = this, {
                        parentElement: t
                    } = e;
                    null == t || t.removeChild(e)
                }
                static validateProps(e) {
                    const {
                        size: t,
                        imageRange: o,
                        voiRange: n
                    } = e;
                    if (t && !At(t)) throw new Error('Invalid "size"');
                    if (o && !mt(o)) throw new Error('Invalid "imageRange"');
                    if (n && !mt(n)) throw new Error('Invalid "voiRange"')
                }
                _setCanvasSize(e, t) {
                    const {
                        width: o,
                        height: n
                    } = t;
                    e.width = o, e.height = n, Object.assign(e.style, {
                        width: `${o}px`,
                        height: `${n}px`
                    })
                }
                _createRootElement(e) {
                    const t = document.createElement("canvas");
                    return Object.assign(t.style, {
                        position: "absolute",
                        top: "0",
                        left: "0",
                        pointerEvents: "none",
                        boxSizing: "border-box"
                    }), this._setCanvasSize(t, e), t
                }
                render() {
                    if (!this._canvas.isConnected) return;
                    const {
                        _colormap: e
                    } = this, {
                        RGBPoints: t
                    } = e, o = t.length / 4, n = e => {
                        const n = 4 * e;
                        if (!(e < 0 || e >= o)) return {
                            index: e,
                            position: t[n],
                            color: [t[n + 1], t[n + 2], t[n + 3]]
                        }
                    }, {
                        width: i,
                        height: r
                    } = this._canvas, s = this._canvas.getContext("2d"), a = i > r, l = a ? i : r, {
                        _voiRange: d
                    } = this, c = this._showFullImageRange ? this._imageRange : Object.assign({}, d), {
                        windowWidth: u
                    } = _e.toWindowLevel(d.lower, d.upper);
                    let v, g = n(0);
                    const A = (c.upper - c.lower) / (l - 1);
                    let m = c.lower;
                    s.clearRect(0, 0, this._canvas.width, this._canvas.height), s.globalAlpha = .65;
                    for (let e = 0; e < l; e++) {
                        const t = (m - d.lower) / u;
                        if (g)
                            for (let e = g.index; e < o && !(t <= g.position); e++) v = g, g = n(e + 1);
                        let l;
                        if (v)
                            if (g) {
                                const e = (t - v.position) / (g.position - v.position);
                                l = gt(v.color, g.color, e)
                            } else l = [...v.color];
                        else l = [...(null == g ? void 0 : g.color) || []];
                        const c = l.map((e => {
                            return t = Math.round(255 * e), o = 0, n = 255, Math.max(o, Math.min(n, t));
                            var t, o, n
                        }));
                        s.fillStyle = `rgb(${c[0]}, ${c[1]}, ${c[2]})`, a ? s.fillRect(e, 0, 1, r) : s.fillRect(0, r - e - 1, i, 1), m += A
                    }
                }
            }
            var ft = o(9473),
                It = o(7426);
            const Tt = class {
                    constructor(e) {
                        this.VOTListener = (0, ft.sg)((e => {
                            var t, o, n, i;
                            null !== (t = this.VOIRangeDefault) && void 0 !== t || (this.VOIRangeDefault = e.detail.range), !this.isDragging && this.setSliderValue((this.VOIRangeDefault.upper - (null !== (n = null === (o = this.viewport.getProperties().voiRange) || void 0 === o ? void 0 : o.upper) && void 0 !== n ? n : NaN)) / this.VOIRangeDefault.upper + .5), null === (i = this.viewport.getProperties().voiRange) || void 0 === i || i.upper
                        }), 10);
                        const {
                            viewportId: t,
                            container: o,
                            renderingEngine: n
                        } = e;
                        this.viewportId = t, this.container = o, this.renderingEngine = n, this.viewport = this.renderingEngine.getViewport(this.viewportId), this.viewport && this.render()
                    }
                    VOTChangeEventListener() {
                        this.viewport.element.addEventListener(It.A.VOI_MODIFIED, this.VOTListener)
                    }
                    setSliderValue(e) {
                        this.thumb && (this.thumb.style.left = 100 * e + "%")
                    }
                    reset() {
                        this.VOIRangeDefault = void 0
                    }
                    destroy() {
                        var e;
                        try {
                            this.viewport.element.removeEventListener(It.A.VOI_MODIFIED, this.VOTListener), null === (e = this.thumb) || void 0 === e || e.remove()
                        } catch (e) {
                            console.error(e)
                        }
                    }
                    render() {
                        const {
                            isMobile: e
                        } = A.A, t = this.container;
                        let o = t.querySelector("thumb");
                        o || (this.VOTChangeEventListener(), this.thumb = o = (0, ft.n)({
                            className: "thumb",
                            onclick(e) {
                                e.stopPropagation(), e.preventDefault()
                            }
                        }), t.appendChild(o), o.addEventListener(e ? "touchstart" : "mousedown", (() => {
                            if (!this.VOIRangeDefault) return;
                            const {
                                upper: o
                            } = this.VOIRangeDefault, n = t.getBoundingClientRect(), i = (0, ft.nF)((e => {
                                if (!this.isDragging) return;
                                let i = ((e instanceof TouchEvent ? e.touches[0] : e).clientX - n.left) / t.offsetWidth;
                                i = Math.min(1, Math.max(0, i)), this.setSliderValue(i), this.viewport.setProperties({
                                    voiRange: {
                                        upper: o * (1.5 - i),
                                        lower: 0
                                    }
                                }), this.viewport.render()
                            }), 50), r = () => {
                                this.isDragging = !1, document.removeEventListener(e ? "touchmove" : "mousemove", i), document.removeEventListener(e ? "touchend" : "mouseup", r)
                            };
                            this.isDragging = !0, document.addEventListener(e ? "touchmove" : "mousemove", i), document.addEventListener(e ? "touchend" : "mouseup", r)
                        })))
                    }
                },
                yt = fe.A.rgbPresetNames.map((e => fe.A.getPresetByName(e))),
                Rt = "colorbar-container",
                wt = ["hsv", "2hot", "jet", "rainbow", "nic_Edge", "blot", "Warm to Cool (Extended)", "Rainbow Desaturated", "Rainbow Blended Black", "GnYlRd", "Cold and Hot"];
            let Ot, Lt, Pt = 0;

            function Ct(e) {
                const t = bt(e);
                Ot && t && (Ot.colormap = t)
            }

            function bt(e) {
                return yt.find((({
                    Name: t
                }) => t === e))
            }
            const Mt = function(e) {
                const t = e ? [C.fusion.AXIAL, C.fusion.CORONAL, C.fusion.SAGITTAL] : [C.CT.AXIAL],
                    o = b.querySelector("#" + t[0]);
                let n = b.querySelector(`.${Rt}`);
                Pt = 0, null == n || n.remove(), n = (0, ft.n)({
                    className: Rt,
                    onclick: () => {
                        Pt = (Pt + 1) % wt.length;
                        const e = wt[Pt];
                        Ct(e);
                        for (const o of t) {
                            const t = M.getViewport(o);
                            t.setProperties({
                                colormap: {
                                    name: e
                                }
                            }, C.PT.volumeId), t.render()
                        }
                    }
                }), b.appendChild(n), Ot = new ht({
                    size: {
                        width: n.clientWidth,
                        height: n.clientHeight
                    },
                    colormap: bt(wt[Pt]),
                    imageRange: ut(o, T),
                    voiRange: vt(o, T),
                    container: n
                }), null == Lt || Lt.destroy(), Lt = new Tt({
                    viewportId: e ? C.PT.AXIAL : C.CT.CORONAL,
                    container: n,
                    renderingEngine: M
                })
            };
            var St = o(8398);
            let Et;

            function Nt() {
                if (!Et) throw "viewportGrid is undefined for updateContainerGroup";
                const e = Et.querySelectorAll(".isACS9"),
                    t = "ACS9" === E,
                    o = G(!1);
                if ((0, St.M1)(e, (() => !t), "hidden"), t) return o.forEach((({
                    id: e
                }) => {
                    var t;
                    null === (t = Et.querySelector("#" + e)) || void 0 === t || t.removeAttribute("style")
                })), (0, St.Wp)(Et, {
                    style: "\n      display: grid;\n      grid-template-rows: 1fr 1fr 1fr;;\n      grid-template-columns: 1fr 1fr 1fr;;\n      width: 100%;\n      height: 100%;\n    "
                }), void(0, St.wf)(Et.querySelector("#" + P.VOLUME_3D), !0, "hidden");
                const {
                    isMobile: n
                } = A.A, i = o.filter((e => "rightElement" === e.class && e.visibility)).length, r = 1 / i * 100;
                let s = 0;
                (0, St.Wp)(Et, {
                    style: `\n      display: grid;\n      grid-template-rows:  ${n?"1fr 0.3fr":r+"%"};\n      grid-template-columns: ${n?r:50}%;\n      width: 100%;\n      height: 100%;\n    `
                }), o.forEach((({
                    id: e,
                    class: t,
                    visibility: o
                }, r) => {
                    const a = Et.querySelector("#" + e);
                    a && (a.className = t, "rightElement" === t && o ? (s++, (0, St.Wp)(a, {
                        style: `grid-column-start: ${n?s:2};grid-row-start: ${n?2:s};`
                    })) : "leftElement" === t && o ? (0, St.Wp)(a, {
                        style: n ? `grid-column-start: span ${i};` : `grid-row-start: span ${i};`
                    }) : (0, St.wf)(a, !0, "hidden"), (0, St.Wp)(a, {
                        index: r
                    }))
                }))
            }

            function _t() {
                return M.getVolumeViewports()
            }

            function Dt() {
                return Vt(L)
            }

            function Vt(e) {
                return M.getViewport(e)
            }
            var Gt = o(8712),
                kt = o(9897),
                Ft = function(e, t, o, n) {
                    return new(o || (o = Promise))((function(i, r) {
                        function s(e) {
                            try {
                                l(n.next(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function a(e) {
                            try {
                                l(n.throw(e))
                            } catch (e) {
                                r(e)
                            }
                        }

                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value, t instanceof o ? t : new o((function(e) {
                                e(t)
                            }))).then(s, a)
                        }
                        l((n = n.apply(e, t || [])).next())
                    }))
                };
            const {
                iP: Ut,
                r$: xt
            } = Ge, {
                BlendModes: qt
            } = be, Bt = A.A.webDicomView.layoutView, Xt = new ResizeObserver((() => {
                null == M || M.resize(!0, !0)
            }));

            function Ht(e) {
                return Ft(this, void 0, void 0, (function*() {
                    const t = G(!0).find((e => e.id === L));
                    if (!t) throw "VOLUME3DMap is undefined for initMPRVolume";
                    if (t.visibility = null != e ? e : t.visibility, Nt(), t.visibility) {
                        M.enableElement({
                                viewportId: P.VOLUME_3D,
                                type: Ue.VOLUME_3D,
                                element: b.querySelector("#" + P.VOLUME_3D),
                                defaultOptions: {
                                    orientation: xe.CORONAL
                                }
                            }),
                            function() {
                                Ye();
                                const e = Ke(y, [P.VOLUME_3D]);
                                e.addTool(Y.A.toolName), e.addTool(Z.A.toolName, {
                                    toolGroupId: C.CT.toolGroupId
                                }), e.addTool(Q.A.toolName), e.addTool(W.A.toolName), e.addTool(z.A.toolName), e.addTool(j.A.toolName), e.addTool(ee.A.toolName, {
                                    orientationWidget: {
                                        viewportSize: .2,
                                        minPixelSize: 50,
                                        maxPixelSize: 100
                                    }
                                }), e.setToolActive(Y.A.toolName, {
                                    bindings: [{
                                        mouseButton: He.Wheel
                                    }]
                                }), e.setToolActive(Q.A.toolName, {
                                    bindings: [{
                                        mouseButton: He.Primary
                                    }]
                                }), e.setToolActive(j.A.toolName, {
                                    bindings: [{
                                        numTouchPoints: 2
                                    }]
                                }), e.setToolActive(z.A.toolName, {
                                    bindings: [ze ? {
                                        numTouchPoints: 2
                                    } : {
                                        mouseButton: He.Auxiliary
                                    }]
                                }), e.setToolActive(Z.A.toolName, {
                                    bindings: [{
                                        mouseButton: He.Secondary,
                                        modifierKey: $e.Shift
                                    }]
                                }), e.setToolActive(W.A.toolName, {
                                    bindings: [{
                                        mouseButton: He.Secondary
                                    }]
                                }), e.setToolActive(ee.A.toolName)
                            }();
                        let e = Dt();
                        if (Bt.FusionLayout2.activeSeries) {
                            const t = "CT" === S.modality;
                            yield e.setVolumes([{
                                volumeId: t ? I : T,
                                callback: he
                            }, {
                                volumeId: t ? T : I,
                                callback: Oe
                            }], !1)
                        } else yield e.setVolumes([{
                            volumeId: I
                        }]), Zt()
                    } else Dt() && (M.disableElement(P.VOLUME_3D), Ye());
                    lt(), M.resize(!0, !1)
                }))
            }

            function $t() {
                return Ft(this, void 0, void 0, (function*() {
                    if (M) try {
                        x()
                    } catch (e) {
                        console.error(e)
                    } finally {
                        A.A.DBCacheImages.temporaryEnable = !1, N(null), _({}), U(null), D(null), Bt.FusionLayout2.activeSeries = void 0, (0, St.bE)(b), null == Bt || Bt.mprLayout.hidden(), Ce.events.removeEventNamespaceListener("tool_event.MPR"), Ce.events.removeEventNamespaceListener("tool_WwWc_MPR.MPR")
                    }
                }))
            }

            function Wt(e, t) {
                (0, St.wf)(Bt.querySelectorForTool(".MPRFusion"), e, t)
            }

            function zt(e, t = "CT") {
                const {
                    isFusionMode: o
                } = S, n = "VOLUME_3D" === t ? {
                    VOLUME_3D: {
                        toolGroupId: y
                    }
                } : o ? C : {
                    CT: C.CT
                };
                try {
                    for (const [t, {
                            toolGroupId: o
                        }] of Object.entries(n)) {
                        const t = ke.A(o);
                        t ? Je(t, e, {
                            bindings: [{
                                mouseButton: Ut.Primary
                            }]
                        }, !0) : console.warn("toolGroup is undefined for " + o)
                    }
                } catch (e) {
                    console.error(e)
                }
            }

            function jt() {
                return Ft(this, arguments, void 0, (function*(e = E) {
                    const t = R.map((e => Vt(e))),
                        [o, n, i] = t;
                    if ("ACS9" == e) yield Yt(), o.setOrientation(De.A.AXIAL), n.setOrientation(De.A.SAGITTAL), i.setOrientation(De.A.CORONAL);
                    else {
                        for (const o of t) {
                            const t = De.A[null == e ? void 0 : e.toUpperCase()];
                            t && o.setOrientation(t)
                        }
                        yield n.setVolumes([{
                            volumeId: I
                        }], !1), yield i.setVolumes([{
                            volumeId: T,
                            callback: Pe
                        }], !1), yield o.setVolumes([{
                            volumeId: I,
                            callback: he
                        }, {
                            volumeId: T,
                            callback: Oe
                        }], !1)
                    }
                }))
            }

            function Yt() {
                return Ft(this, arguments, void 0, (function*(e = "all") {
                    if (S.isFusionMode) {
                        if ("3D" === e) return void(yield Dt().setVolumes([{
                            volumeId: I
                        }], !1, !1));
                        yield(0, Ve.A)(M, [{
                            volumeId: I
                        }], R, !1, !1), yield(0, Ve.A)(M, [{
                            volumeId: T,
                            callback: Pe
                        }], w, !1, !1), yield(0, Ve.A)(M, [{
                            volumeId: I,
                            callback: he
                        }, {
                            volumeId: T,
                            callback: Oe
                        }], O, !1, !1)
                    } else {
                        const t = [L];
                        let o = [...R, ...t];
                        "2D" === e ? o = [...R] : "3D" === e && (o = t), yield(0, Ve.A)(M, [{
                            volumeId: I
                        }], o, !1, !1)
                    }
                }))
            }

            function Zt() {
                return Ft(this, void 0, void 0, (function*() {
                    const {
                        gpu: e
                    } = (yield ve.get()) || {};
                    let t = ["CT-Bone", "MR-Default", "default"];
                    if (-1 === A.A.imageType) return console.warn("PNG has no presets");
                    (null == e ? void 0 : e.includes("intel")) && (t = ["default"], console.warn("The Intel GPU may affect your experience"));
                    const o = t.reduce(((e, t) => null != e ? e : Bt.querySelectorForTool(`.${t}:not(.hidden)`, ".MPRViewportPresets")), void 0);
                    null == o || o.click()
                }))
            }

            function Kt(e) {
                _t().forEach((t => {
                    e === qt.COMPOSITE ? t.setSlabThickness(k) : t.getSlabThickness() < 1 && t.setSlabThickness(1), t.setBlendMode(e), t.render()
                }))
            }
            const Jt = {
                    MPRRun: function(e, t) {
                        return Ft(this, void 0, void 0, (function*() {
                            var o;
                            const {
                                isFusionMode: i,
                                modality: r,
                                seriesData: {
                                    matchFusionSeries: s
                                }
                            } = t;
                            var a;
                            _(t), b = e, $t(), b.childElementCount || (b.appendChild((Et = (0, ft.n)({
                                    id: "viewportGrid"
                                }), Et.append((0, ft.n)({
                                    id: C.CT.AXIAL
                                }), (0, ft.n)({
                                    id: C.CT.SAGITTAL
                                }), (0, ft.n)({
                                    id: C.CT.CORONAL
                                }), (0, ft.n)({
                                    id: P.VOLUME_3D
                                })), S.isFusionMode && Et.append((0, ft.n)({
                                    id: C.PT.AXIAL,
                                    className: "PT isACS9"
                                }), (0, ft.n)({
                                    id: C.PT.SAGITTAL,
                                    className: "PT isACS9"
                                }), (0, ft.n)({
                                    id: C.PT.CORONAL,
                                    className: "PT isACS9"
                                }), (0, ft.n)({
                                    id: C.fusion.AXIAL,
                                    className: "fusion isACS9"
                                }), (0, ft.n)({
                                    id: C.fusion.SAGITTAL,
                                    className: "fusion isACS9"
                                }), (0, ft.n)({
                                    id: C.fusion.CORONAL,
                                    className: "fusion isACS9"
                                })), Et)), Xt.observe(b)), s || Wt(!0, "hidden"), A.A.DBCacheImages.temporaryEnable = !0,
                                function() {
                                    Ce.events.addEventNamespaceListener("tool_event.MPR", (e => Ft(this, void 0, void 0, (function*() {
                                        var t, o, i;
                                        const r = e.detail.toolData || {},
                                            {
                                                toolTag: s,
                                                toolType: a,
                                                select: l
                                            } = r;
                                        switch (s) {
                                            case "MPRReload2D":
                                                (0, n.r)("MPRReload2D"), Bt.initTop2DTools();
                                            case "VRT":
                                                (0, n.r)("VRT"), $t();
                                                break;
                                            case "MPRCrosshairs":
                                                zt(J.A.toolName);
                                                break;
                                            case "MPRStackScroll":
                                                zt(K.A.toolName);
                                                break;
                                            case "MPRPan":
                                                zt(z.A.toolName);
                                                break;
                                            case "MPRModulation":
                                                zt(W.A.toolName);
                                            case "MPRModulationMenu":
                                                l && Bt.createWWWCLayout(e);
                                                break;
                                            case "MPRZoom":
                                                zt(j.A.toolName);
                                                break;
                                            case "MPRComposite":
                                                Kt(qt.COMPOSITE);
                                                break;
                                            case "MPRMaxIntensity":
                                                Kt(qt.MAXIMUM_INTENSITY_BLEND);
                                                break;
                                            case "MPRMinIntensity":
                                                Kt(qt.MINIMUM_INTENSITY_BLEND);
                                                break;
                                            case "MPRAverageIntensity":
                                                Kt(qt.AVERAGE_INTENSITY_BLEND);
                                                break;
                                            case "MPRThickness":
                                                {
                                                    const t = new Set;
                                                    (c = Se.A.ORTHOGRAPHIC, _t().filter((({
                                                        type: e
                                                    }) => e === c))).forEach((e => {
                                                        t.add(e.getSlabThickness())
                                                    }));
                                                    const o = [...t];Bt.ThicknessLayout.createLayout(e.detail, 1 === o.length ? o[0] : -1, k);
                                                    break
                                                }
                                            case "MPRThicknessChange":
                                                d = e.detail.value, _t().forEach((e => {
                                                    e.setSlabThickness(d), e.render()
                                                }));
                                                break;
                                            case "MPRReset":
                                                ! function() {
                                                    Ft(this, void 0, void 0, (function*() {
                                                        var e;
                                                        if (S.isFusionMode) Yt(), jt(), Ct(wt[0]), null == Lt || Lt.reset();
                                                        else
                                                            for (const t of _t())(null === (e = t.getDefaultActor()) || void 0 === e ? void 0 : e.actor) && (yield t.setVolumes([{
                                                                volumeId: I
                                                            }], !1));
                                                        Bt.FusionLayout2.activeSeries = void 0, Wt(!1, "active"), Zt(), M.resize(!0, !1)
                                                    }))
                                                }();
                                                break;
                                            case "MPRLevel":
                                                {
                                                    const {
                                                        recommendLevel: e
                                                    } = S,
                                                    {
                                                        MPRLevel: t,
                                                        inputDataError: o
                                                    } = de.Ay.translate("toast") || {},
                                                    n = String(e),
                                                    i = 1,
                                                    r = 10,
                                                    s = yield(0, kt.A)(t, (e => /^\d+(\.\d*)?$/.test(e) && e >= i && e <= r), o, n, {
                                                        inputs: [
                                                            [(0, St.sJ)(Array.from({
                                                                length: 10
                                                            }, ((e, t) => ({
                                                                value: String(t + 1)
                                                            }))), n).outerHTML, "change", function(e, t, o, n) {}, !0]
                                                        ]
                                                    });
                                                    if (null !== s) {
                                                        const {
                                                            isFusionMode: e,
                                                            originalSeriesData: t,
                                                            modality: o
                                                        } = S;
                                                        yield $t(), A.A.webDicomView.initMPR({
                                                            isFusionMode: e,
                                                            levelDefault: Number(s),
                                                            modality: o,
                                                            originalSeriesData: t
                                                        })
                                                    }
                                                    break
                                                }
                                            case "MPRApplyPreset":
                                                {
                                                    const e = null === (o = null === (t = Dt()) || void 0 === t ? void 0 : t.getDefaultActor()) || void 0 === o ? void 0 : o.actor;
                                                    if (!e) return;
                                                    switch (a) {
                                                        case "default":
                                                            Yt("3D");
                                                            break;
                                                        default:
                                                            {
                                                                const t = Ee.A.find((e => e.name === a));t && Ne.A(e, t);
                                                                break
                                                            }
                                                    }
                                                    M.render();
                                                    break
                                                }
                                            case "MPRVolume":
                                                yield Ht(!(null === (i = Dt()) || void 0 === i ? void 0 : i.getDefaultActor()));
                                                break;
                                            case "MPRApplyFusionLayout":
                                                {
                                                    if (E === a) return;
                                                    const e = "ACS9" === a,
                                                        t = Bt.querySelector(".toolsMPR");t && (0, St.Wp)(t, {
                                                        layoutType: String(a)
                                                    }),
                                                    D(a),
                                                    Nt(),
                                                    yield jt(),
                                                    jt(),
                                                    lt(),
                                                    M.resize(!0, !1),
                                                    Mt(e);
                                                    break
                                                }
                                            case "MPRFusion":
                                                Bt.FusionLayout2.createLayout(e.detail, S.seriesData.matchFusionSeries);
                                                break;
                                            case "MPRFusionChange":
                                                {
                                                    const t = _t().filter((e => e.getDefaultActor())),
                                                        {
                                                            activeSeries: o
                                                        } = e.detail;
                                                    if (o) {
                                                        const e = "CT" === S.modality;
                                                        (yield q.createAndCacheVolume(T, {
                                                            imageIds: o.loadIds
                                                        })).load(), t.forEach((t => {
                                                            t.setVolumes([{
                                                                volumeId: e ? I : T,
                                                                callback: he
                                                            }, {
                                                                volumeId: e ? T : I,
                                                                callback: Oe
                                                            }], !0)
                                                        }))
                                                    } else t.forEach((e => {
                                                        e.setVolumes([{
                                                            volumeId: I
                                                        }], !0)
                                                    }));Wt(!!o, "active");
                                                    break
                                                }
                                        }
                                        var d, c;
                                        switch (s) {
                                            case "MPRModulation":
                                                zt(W.A.toolName, "VOLUME_3D");
                                                break;
                                            case "MPRZoom":
                                                zt(j.A.toolName, "VOLUME_3D");
                                                break;
                                            case "MPRApplyPreset":
                                                break;
                                            default:
                                                {
                                                    const {
                                                        isLonelyGroup: e,
                                                        isToggle: t,
                                                        disActive: o
                                                    } = r;
                                                    if (e || t || o) return;zt(Q.A.toolName, "VOLUME_3D")
                                                }
                                        }
                                    })))), Ce.events.addEventNamespaceListener("tool_WwWc_MPR.MPR", (e => Ft(this, void 0, void 0, (function*() {
                                        const [t, o] = yield Bt.wwwcLayout.getWindowRange(e.detail), n = Vt(R[0]);
                                        n.setProperties({
                                            voiRange: _e.toLowHighRange(t, o)
                                        }), n.render()
                                    }))))
                                }(), yield pe(), N(new Me.Ay(p));
                            try {
                                yield function() {
                                    return Fe(this, void 0, void 0, (function*() {
                                        const {
                                            isFusionMode: e
                                        } = S, t = [{
                                            viewportId: C.CT.AXIAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.CT.AXIAL),
                                            defaultOptions: {
                                                orientation: xe.AXIAL
                                            }
                                        }, {
                                            viewportId: C.CT.SAGITTAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.CT.SAGITTAL),
                                            defaultOptions: {
                                                orientation: xe.SAGITTAL
                                            }
                                        }, {
                                            viewportId: C.CT.CORONAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.CT.CORONAL),
                                            defaultOptions: {
                                                orientation: xe.CORONAL
                                            }
                                        }];
                                        let o = [];
                                        e && (o = [{
                                            viewportId: C.PT.AXIAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.PT.AXIAL),
                                            defaultOptions: {
                                                orientation: xe.AXIAL
                                            }
                                        }, {
                                            viewportId: C.PT.SAGITTAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.PT.SAGITTAL),
                                            defaultOptions: {
                                                orientation: xe.SAGITTAL
                                            }
                                        }, {
                                            viewportId: C.PT.CORONAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.PT.CORONAL),
                                            defaultOptions: {
                                                orientation: xe.CORONAL
                                            }
                                        }, {
                                            viewportId: C.fusion.AXIAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.fusion.AXIAL),
                                            defaultOptions: {
                                                orientation: xe.AXIAL
                                            }
                                        }, {
                                            viewportId: C.fusion.SAGITTAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.fusion.SAGITTAL),
                                            defaultOptions: {
                                                orientation: xe.SAGITTAL
                                            }
                                        }, {
                                            viewportId: C.fusion.CORONAL,
                                            type: Ue.ORTHOGRAPHIC,
                                            element: b.querySelector("#" + C.fusion.CORONAL),
                                            defaultOptions: {
                                                orientation: xe.CORONAL
                                            }
                                        }]), M.setViewports([...t, ...o]);
                                        const {
                                            fusionData: n,
                                            series: i
                                        } = S.seriesData;
                                        try {
                                            e && n ? yield Promise.all([qe(C.CT.volumeId, n.CT.loadIds), qe(C.PT.volumeId, n.PT.loadIds)]): i && (yield qe(C.CT.volumeId, i.loadIds))
                                        } catch (e) {
                                            throw console.error("load", e), e
                                        }
                                    }))
                                }(), yield Yt("2D"), yield Ht(),
                                    function() {
                                        function e(e) {
                                            return je[e.split("_")[1]]
                                        }
                                        const {
                                            isFusionMode: t
                                        } = S, o = t ? C : {
                                            CT: C.CT
                                        };
                                        for (const [t, {
                                                toolGroupId: n,
                                                viewportIds: i
                                            }] of Object.entries(o)) {
                                            Be.A(n);
                                            const o = Ke(n, i);
                                            o.addTool(W.A.toolName, "fusion" === t ? {
                                                volumeId: C.PT.volumeId
                                            } : void 0), o.addTool(z.A.toolName), o.addTool(j.A.toolName, {}), o.addTool(K.A.toolName), o.addTool(J.A.toolName, {
                                                viewportIndicators: !0,
                                                getReferenceLineColor: e,
                                                filterActorUIDsToSetSlabThickness: "fusion" === t ? [C.CT.volumeId] : void 0
                                            }), o.setToolActive(j.A.toolName, {
                                                bindings: [{
                                                    numTouchPoints: 2
                                                }]
                                            }), o.setToolActive(z.A.toolName, {
                                                bindings: [ze ? {
                                                    numTouchPoints: 2
                                                } : {
                                                    mouseButton: He.Auxiliary
                                                }]
                                            }), o.setToolActive(W.A.toolName, {
                                                bindings: [{
                                                    mouseButton: He.Secondary
                                                }]
                                            }), o.setToolActive(K.A.toolName, {
                                                bindings: [{
                                                    mouseButton: He.Wheel
                                                }]
                                            })
                                        }
                                    }(),
                                    function(e) {
                                        const t = 0 === (0, Gt.Fb)(e).length;
                                        (0, St.M1)(Bt.toolsContainer.querySelectorAll(".MPRViewportPresets .tool-event-link"), (o => {
                                            if (t) return !1; {
                                                const {
                                                    toolType: t
                                                } = o.dataset;
                                                return "default" !== t && !(null == t ? void 0 : t.includes(e))
                                            }
                                        }), "hidden")
                                    }(r),
                                    function() {
                                        const e = e => {
                                            var t;
                                            if ("ACS9" === E) return;
                                            const o = null === (t = e.target.parentElement) || void 0 === t ? void 0 : t.parentElement,
                                                n = Et.querySelector(".leftElement");
                                            if (o && n && o !== n) {
                                                const e = o.getAttribute("index"),
                                                    t = n.getAttribute("index");
                                                if (null === t || null === e) throw "currentTargetIndex and currentLeftIndex is undefined for viewportGridBindDoubleClick";
                                                const i = G(!1),
                                                    r = i[parseFloat(t)],
                                                    s = i[parseFloat(e)],
                                                    a = Object.assign({}, r);
                                                r.style = s.style, r.class = s.class, s.style = a.style, s.class = a.class, Nt(), M.resize(!0, !1)
                                            }
                                        };
                                        A.A.isMobile ? new Hammer(Et).on("doubletap", e) : Et.addEventListener("dblclick", e)
                                    }(), a = Vt(C.CT.AXIAL).getSlabThickness(), k = a
                            } catch (e) {
                                throw console.error(e), e
                            }
                            i && (null === (o = Bt.querySelectorForTool(".MPRFusionLayout .active")) || void 0 === o || o.click())
                        }))
                    },
                    MPRDestroy: $t
                },
                Qt = Jt
        }
    }
]);